//  P2615 [NOIP 2015 提高组] 神奇的幻方
/* 题目描述
 幻方是一种很神奇的 N * N 矩阵：它由数字 1,2,3,…,N * N 构成，且每行、每列及两条对角线上的数字之和都相同。
 当 N 为奇数时，我们可以通过下方法构建一个幻方：*/

/* 经典幻方算法（最好背诵此模板）
首先将 1 写在第一行的中间。
之后，按如下方式从小到大依次填写每个数 K  (K=2,3,...,N * N) :
1. 若 (K-1) 在第一行但不在最后一列，则将 K 填在最后一行， (K-1) 所在列的右一列；
2. 若 (K-1) 在最后一列但不在第一行，则将 K 填在第一列， (K-1) 所在行的上一行；
3. 若 (K-1) 在第一行最后一列，则将 K 填在 (K-1) 的正下方；
4. 若 (K-1) 既不在第一行，也不在最后一列，如果 (K-1) 的右上方还未填数，则将 K 填在 (K-1) 的右上方，否则将 K 填在 (K-1) 的正下方。*/

/* 此算法可以简化为：
    1. 第一个数字1放在第一行中间
    2. 后续数字放在当前数字的右上格
    3. 如果该位置已有数字或超出边界，则放在正下方。*/

/* 现给定 N ，请按上述方法构造 N * N 的幻方。
输入格式
    一个正整数 N，即幻方的大小。
输出格式
    共 N 行，每行 N 个整数，即按上述方法构造出的 N * N 的幻方，相邻两个整数之间用单空格隔开。*/


#include<stdio.h>
int main(){
    int n;
    scanf("%d",&n);

    if(n%2==0){
        return 0;
    }

    int a[n][n];
    for(int i =0;i<n;i++){
        for(int j =0;j<n;j++){
            a[i][j]=0;
        }
    }

    int row=0;
    int col=n/2;
    a[row][col] = 1;

    for(int k=2;k<=n*n;k++){
        if(row==0&&col!=n-1){
            row=n-1;
            col=col+1;
        }else if(col==n-1&&row!=0){
            row=row-1;
            col=0;
        }else if(row==0&&col==n-1){
            row=row+1;
        }else if(row!=0&&col!=n-1){
            if(a[row-1][col+1]==0){
                row=row-1;
                col=col+1;
            }else{
                row=row+1;
            }
        }
        a[row][col]=k;          // 只对数组编号操作，可以简化时间复杂度
    }

    for(int i =0;i<n;i++){
        for(int j =0;j<n;j++){
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
   
    return 0;
}