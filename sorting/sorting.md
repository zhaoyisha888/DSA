# 排序问题的一般思路（套路）
排序本质思想，就是比较两个数据的大小，然后交换位置，从而使整个序列有序（从小到大或从大到小）。

## 解决排序问题的一般步骤（套路）

### 步骤1：确定数据结构
- 是单独的变量？（如 a, b, c）→ 适合写死交换
- 是一组数？（如 int arr[n]）→ 适合用数组 + 排序算法

### 步骤2：选择排序方式
根据数据规模与需求，选择合适的排序方法：

| 排序方式       | 核心思想               | 时间复杂度      | 适用场景                | 特点                        |
| -------------- | ---------------------- | --------------- | ----------------------- | --------------------------- |
| 手写交换逻辑   | 直接 if 判断并交换      | O(1)            | 固定少量数据（如3个）    | 快速直接，代码简洁           |
| 冒泡排序       | 相邻两数交换           | O(n?)           | 简单逻辑、易于实现        | 每次将最大/最小“冒”到顶      |
| 选择排序       | 每轮选最小与当前位置交换 | O(n?)           | 稳定、逻辑清晰           | 每轮选出最小/最大值          |
| 插入排序       | 每次插入到前面有序区    | O(n?)           | 小数据、基本有序时        | 类似扑克牌插牌过程           |
| 快速排序       | 选基准分左右递归        | O(n log n)      | 中大数据                 | 递归、效率高                 |
| 归并排序       | 分治合并                | O(n log n)      | 大数据                   | 稳定、效率高                 |
| 系统函数排序   | 调用库函数              | 依赖实现         | `qsort()`、`sort()`等     | 稳定可靠，推荐优先使用       |

### 步骤3：实现比较和交换逻辑
? 这是排序最基础的“**原子操作**”
1. 比较两个数时：
```c
if (a > b) {
    temp = a;
    a = b;
    b = temp;
}
```
2. 对数组排序：
```c
for (int i = 0; i < n-1; i++) {
    for (int j = 0; j < n-1-i; j++) {
        if (arr[j] > arr[j+1]) {
            temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
```
### temp 的作用
变量 temp 的作用就是：**临时保存数据，防止被覆盖**。




### 三数排序
可以用多种方法实现，例如：
- 直接 if 判断并交换
- 使用数组并调用排序函数（如 qsort）
- 手写冒泡或选择排序（对于只有3个数来说都非常轻量）
#### 思路
这段程序通过三次比较+交换，确保 a 最小，c 最大，b 中间：
- 第一步：让 a <= b
- 第二步：让 a <= c
- 第三步：让 b <= c，于是最终有：a <= b <= c
其实是**冒泡排序中的一轮简化版本**

