## 方法1 构造比较函数
标准库函数 `qsort` 在输入完成后排序整个数组,比较函数 `compare` 定义升序规则。
**输出逻辑**：排序后 a[0] 是最小值

### 为什么qsort不能直接比较？
C语言中，`qsort`函数是一个通用的排序函数，它可以对任意类型的数组进行排序。但是，由于它不知道数组中元素的类型以及如何比较两个元素的大小，因此需要用户提供一个比较函数（`comparator function`）来告诉`qsort`如何比较两个元素。

### 比较函数的原型如下：
```c
int compare(const void *a, const void *b);
```
这个函数应该返回：
- 负数：即`a`小于`b`，在升序排序中
- 正数：即`a`大于`b`，在降序排序中
- 0：`a`=`b`（顺序无关紧要）
在比较函数内部，我们需要**将`void*`指针转换为实际数据类型的指针**（例如`int*`），然后解引用得到值。
```c
int compare(const void *a, const void *b) {
    return (*(int*)(x) - *(int*)(y));
}
```
  1. 将泛型指针 void* 转换为 int* 指针
  2. 解引用获取实际整数值
  3. 返回 a - b 实现升序排序

### 为什么比较函数是必要的设计？
|场景|	比较函数写法|	说明|
|:----:|:----:|:----:|
|整数升序|	return \*(int*)a - \*(int*)b;	|最常用|
|整数降序|	return \*(int*)b - \*(int*)a;	|最常用|
|浮点数升序|	return (\*(float*)a > \*(float*)b) ? 1 : -1;	|避免减法精度问题|
|按字符串长度排序|	return strlen(\*(char**)a) - strlen(\*(char**)b);	|按字符串长度排序|
|按结构体字段排序|	return ((Person*)a)->age - ((Person*)b)->age;	|按结构体字段排序|

## 方法2 
C 语言没有内置的排序算法，`qsort` 是标准库提供的通用排序工具。如果不想写比较函数，也可以使用冒泡排序
 **冒泡排序**：
一种简单的排序算法，它重复走访要排序的数列，一次比较两个元素，如果它们的顺序错误，就交换它们的位置。**走访数列的次数为数列的长度减 1**。

 **冒泡排序算法特性**：
1. 时间复杂度：
最坏/平均情况：O(n?) （嵌套循环）
最好情况（已有序）：O(n) （需添加提前终止判断）
2. 空间复杂度：O(1) （原地排序，仅使用常数级额外空间）
3. 稳定性：稳定排序（相等元素不交换）
4. 冒泡排序简单，但对于大规模数据效率较低，通常用于教学或小规模数据排序。


### 冒泡排序的过程可以这样理解：

   - 第一轮（i=0）：从第一个元素到倒数第二个元素（j从0到n-2），依次比较相邻元素，如果前一个比后一个大就交换。这样一轮下来，最大的元素就会“冒泡”到最后一个位置（即a[n-1]）。
   - 第二轮（i=1）：因为最后一个元素已经是最大的，所以只需要比较前n-2个元素（即j从0到n-3）。第二轮结束后，第二大的元素就会在倒数第二个位置（a[n-2]）。
   - 依此类推，直到第n-1轮（i=n-2），比较前两个元素（j=0），将较大的放到第二个位置（此时最小的在第一个位置，最大的在最后，整个数组有序）。
**注意**：冒泡排序有一个优化点，就是如果在一轮遍历中没有发生任何交换，说明数组已经有序，可以提前结束排序。但上述代码没有做这个优化。

### 例子
```c
// 简单的冒泡排序
for (int i = 0; i < n-1; i++) {
    for (int j = 0; j < n-i-1; j++) {
        if (a[j] > a[j+1]) {
            int temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
        }
    }
```
解释这段代码：
 1. 外层循环：`for (int i = 0; i < n-1; i++)`
    - 变量`i`表示已经排序完成的元素个数，也可以理解为每一轮排序后，最大的元素会“冒泡”到数组的末尾，因此下一轮就不需要再考虑最后一个元素（因为已经是最大的了）。
    - 循环次数为`n-1`次，因为如果有`n`个元素，最多只需要`n-1`轮排序就可以完成（最后一轮只剩下一个元素，自然有序）。
 2. 内层循环：`for (int j = 0; j < n-i-1; j++)`
    - 变量`j`表示当前正在比较的元素位置。
    - 循环条件`j < n-i-1`：因为经过`i`轮排序后，数组末尾的`i`个元素已经是排好序的（是最大的`i`个元素），所以内层循环只需要遍历到`n-i-1`的位置（因为每次比较`a[j]`和`a[j+1]`，所以最后一个要比较的位置是`n-i-2`和`n-i-1`，当`j`等于`n-i-1`时，`a[j+1]`就会越界）。
 3. 比较相邻元素：`if (a[j] > a[j+1])`
    - 如果当前元素`a[j]`大于下一个元素`a[j+1]`，则交换它们（因为升序排序要求前面的元素小于等于后面的元素）。
 4. 交换元素：
    ```c
    int temp = a[j];
    a[j] = a[j+1];
    a[j+1] = temp;
    ```
    - 使用一个临时变量`temp`来交换`a[j]`和`a[j+1]`的值。

### 示例
**初始数组**： [5,3,8,6,4]
1. **第一轮（i=0）**：
- 比较5和3 -> 交换 -> [3,5,8,6,4]
- 比较5和8 -> 不交换 -> [3,5,8,6,4]
- 比较8和6 -> 交换 -> [3,5,6,8,4]
- 比较8和4 -> 交换 -> [3,5,6,4,8]   // 第一轮结束，8到了最后
2. **第二轮（i=1）**：
- 比较3和5 -> 不交换
- 比较5和6 -> 不交换
- 比较6和4 -> 交换 -> [3,5,4,6,8]   // 第二轮结束，6到了倒数第二
3. **第三轮（i=2）**：
- 比较3和5 -> 不交换
- 较5和4 -> 交换 -> [3,4,5,6,8]   // 第三轮结束，5到了倒数第三
4. **第四轮（i=3）**：
- 比较3和4 -> 不交换 -> 数组已经有序，结束。

由于我们进行了4轮（n=5，所以n-1=4），排序完成。


