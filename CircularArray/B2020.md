# 题目关键点：区分题目类型
## **顺序模拟题**，
每个小朋友的操作是基于**当前状态**进行的，必须**按照 1~5 顺序依次执行，每一步更新都立即生效**。
### 正确认知

    - 1 号小朋友先分糖果，此时 2 号、5 号立即获得糖果；
    - 到 2 号小朋友时，他手里的糖果已经是：原始 + 1 号分给他的；
    - 依此类推，操作必须是依次进行、实时更新状态。

### 正确的模拟方式

1. 初始数组 candies = [a1, a2, a3, a4, a5]
2. 遍历 i=04（对应编号 15）
3. 每一步：
   - 取出 candies[i] 当前数量
   - 计算 q = candies[i] // 3（每份）
   - candies[i] %= 3（自己吃掉剩余的 + 留一份 = 1 份）
   - 然后：candies[i] += q（自己保留一份）
   - candies[(i - 1) % 5] += q（左边）
   - candies[(i + 1) % 5] += q（右边）
   - 累加吃掉的糖果数量 r = candies[i] - 3*q（就是 % 3）


## 环形数组类型解法
如果分糖果操作是基于初始状态进行的，也就是说每个人的分糖果都是基于游戏开始时的糖果数，不是操作过程中实时更新的糖果数。
“邻居”关系是环状的，第1个的左邻是第5个，右邻是第2个；以此类推。
每人吃掉的糖果是“自己分糖果时剩余的糖果（糖果数%3）”。

**这是模拟题的经典套路，建议你记住这几个提示**：
| 遇到场景               | 要点/技巧                 |
| ------------------ | --------------------- |
| 每个人依次操作，操作之间不能相互影响 | 要用两个数组，一个保存原始值，一个保存结果 |
| 环形结构（比如围圈、首尾相连）    | 用 `%` 运算符处理下标循环       |
| 模拟操作中每一步逻辑清晰       | 不要想数学公式，照着题意“翻译成代码”   |

>模拟题三宝：
原始数组保操作数据
结果数组存操作结果
邻居用 (i ± offset + n) % n 保证不越界

### **解题思路**
1. 读入5个整数，表示5个小朋友初始糖果数，存入数组 init[5]。
2. 新建一个数组 res[5] 初始化为0，表示一轮结束后每个人最终糖果数。
3. 新建一个变量 eaten，统计吃掉的糖果总数。
4. 遍历每个小朋友 i：
   - 计算均分后每份糖果数 share = init[i] / 3
   - 计算吃掉的糖果数 eat = init[i] % 3
   - 自己加上 share
   - 左邻居加上 share
   - 右邻居加上 share
   - eaten += eat
5. 输出 res 数组和 eaten

### 一、为什么要创建数组 init[5] 和 res[5]？
题目本质是“**模拟操作**”，而不是数学公式计算
题目说：“每个人依次操作，但每个人操作时，用的是最初的糖果数”，而结果是在所有人操作完成后，所以必须保留原始数据。
所以：
    init[5] → 存储初始糖果（用于计算“该分多少”）
    res[5] → 存储操作后每个人手里的糖果（最终结果）

> 如果只用一个数组，会出现什么问题？
第1个人操作完就改变了糖果数，第2个人用到的数据就被“污染”了，无法复原了，所以必须“分开保存”。

### 二、左右邻居的计算为什么是 (i + 4) % 5 和 (i + 1) % 5？
**因为是环形结构**
人的编号是：1 2 3 4 5（数组是从下标 0 到 4）
他们围成一个圆：
第1个人的左邻居是第5人，右邻居是第2人
第5个人的左邻居是第4人，右邻居是第1人
所以我们要“绕圈”：如果到头了，重新从0开始或回到4。

>举个例子
>当前是 i = 0（第1个人）
    左邻居是 (i + 4) % 5 = (0 + 4) % 5 = 4（第5个人）
    右邻居是 (i + 1) % 5 = 1（第2个人）
>当前是 i = 4（第5个人）
    左邻居是 (4 + 4) % 5 = 8 % 5 = 3（第4个人）
    右邻居是 (4 + 1) % 5 = 5 % 5 = 0（第1个人）

